/* autogenerated by Processing preprocessor v3.0.0 on 2021-04-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.concurrent.TimeUnit;
import static javax.swing.JOptionPane.*;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.DisplayMode;
import java.awt.GridBagLayout;
import java.awt.Window;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Container;
import java.awt.Canvas;
import java.awt.Color;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.util.*;
import java.lang.reflect.*;
import processing.awt.PSurfaceAWT.SmoothCanvas;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Jump_Platformer_Game extends PApplet {























SoundFile death;
SoundFile win;
SoundFile toggle;
SoundFile button;
SoundFile complete;

Mode GameMode = Mode.Launcher;
Mode ReturnMode = Mode.LevelEditor;
Player p;
RadioButtonList resList;
RadioButtonList fullResList;
CheckBox fullScreenBox;
Tile editTile;
ArrayList<Enemy> enemies = new ArrayList();
ArrayList<Enemy> kill = new ArrayList();

byte[] arrows = new byte[5];

boolean click = false;
boolean debug = false;
boolean onoffstate = true;
boolean godMode = false;
boolean story=false;

String version = "";
String defRes = "";
String saveFilePath = "";
JSONArray levelPack;

JSONObject settings;

PImage eraser;

float scrollX=0;
float scrollY=0;
float vol = 0;

int tileSize = 0;
int selectedTile = 0;
int scrX = 40;
int[][] inventoryTiles = {{1, 2, 4, 5}, {6, 13, 3}, {7, 8, 14}, {9, 10, 11}, {12}};
int selectedWidth = 1;
int selectedHeight = 1;
int level=0;
int deaths=0;
int fade = 0;
int scrollArb1=0;
int scrollArb2=0;
int scrollArb3=0;

long time=0;
long end=0;

PFont gameFont;

PVector respawnPos = new PVector(0, 0);

Level currentLevel;
File[] levels;

 public void settings() {
  PVector midRange = new PVector(0, 0);
  for (float x=800; x<=displayWidth; x+=10) {
    for (float y=600; y<=displayHeight; y+=10) {
      if (x/y == 4f/3) {
        if (x>(displayWidth/2)-(displayWidth/5) && x<(displayWidth/2)+(displayWidth/5) && y>(displayHeight/2)-(displayWidth/5) && y<(displayHeight/2)+(displayWidth/5)) {
          midRange = new PVector(x, y);
        }
      }
    }
  }
  size((int)midRange.x, (int)midRange.y);
  settings = loadJSONObject("settings.json");
  version = settings.getString("version");
  defRes = settings.getString("defRes");
  gameFont = loadFont("Cambria-BoldItalic-48.vlw");
  death = new SoundFile(this, "death.wav");
  win = new SoundFile(this, "win.wav");
  toggle = new SoundFile(this, "click.wav");
  complete = new SoundFile(this, "complete.wav");
  button = new SoundFile(this, "button.wav");
}

 public void setup() {
  surface.setTitle("Jump! - A Launch Screen");
  resList = new RadioButtonList();
  fullResList = new RadioButtonList();
  textFont(gameFont);
  int i=0;
  int j=0;
  int k=0;
  for (float x=800; x<=displayWidth; x+=10) {
    for (float y=600; y<=displayHeight; y+=10) {
      if (x/y == 4f/3 || x/y == 16f/9) {
        textSize(20);
        String name = PApplet.parseInt(x)+"x"+PApplet.parseInt(y)+ " ("+((x/y == 4f/3)?"4:3":"16:10")+")";
        if (name.equalsIgnoreCase(defRes))
          resList.add(new RadioButton(new Rect(10 + (250*j), 6+(34*i), 40 + textWidth(name), 32), name, true));
        else
          resList.add(new RadioButton(new Rect(10 + (250*j), 6+(34*i), 40 + textWidth(name), 32), name));
        i++;
        if (x==displayWidth || y == displayHeight) {
          if (name.equalsIgnoreCase(defRes))
            fullResList.add(new RadioButton(new Rect(10, 6+(34*k), 40 + textWidth(name), 32), name, true));
          else
            fullResList.add(new RadioButton(new Rect(10, 6+(34*k), 40 + textWidth(name), 32), name));
          k++;
        }
        if (i>10) {
          i=0;
          j++;
        }
      }
    }
  }
  boolean any = false;
  for (RadioButton r : fullResList.buttons)if (r.state) any=true;
  if (!any) {
    fullResList.buttons.get(0).state=true;
    fullResList.buttons.get(0).enableTime=System.currentTimeMillis();
  }
  println(fullResList.buttons.get(0).state);
  any = false;
  for (RadioButton r : resList.buttons)if (r.state) any=true;
  if (!any) {
    resList.buttons.get(0).state=true;
    resList.buttons.get(0).enableTime=System.currentTimeMillis();
  }
  surface.setResizable(false);
  tileSize = floor(height/11);
  eraser = loadImage("eraser.png");
  eraser.resize(60, 60);
  p = new Player(0, 0);
  fullScreenBox = new CheckBox(new Rect(20, height-50, 75, 50), "Fullscreen");
  try {
    fullScreenBox.state = settings.getBoolean("fullscreen");
  }
  catch(NullPointerException ignored) {
  }
  float amp = settings.getFloat("amp");
  complete.amp(amp);
  toggle.amp(amp);
  death.amp(amp);
  win.amp(amp);
  button.amp(amp);
}

 public void draw() {
  fade-=3;
  float menuButtonWidth = width/2.7f;
  float titleTextSize = width/30;
  float subTitleTextSize = width/50;
  if (GameMode != Mode.LevelEditor && GameMode != Mode.EditorInventory && GameMode != Mode.SaveLevel && GameMode != Mode.LoadLevel && GameMode != Mode.EditTile) {
    tileSize = floor(height/11);
  }
  if (GameMode!=Mode.MainGame) {
    story=false;
    enemies.clear();
  }
  background(151);
  strokeWeight(1);
  switch(GameMode) {
  case Launcher:
    (new Button(new Rect(width-100, height-75, 75, 50), "launchGame", "Launch Game", this)).render();
    fullScreenBox.render();
    fill(255);
    rect(10, 380, width-20, 20);
    fill(100);
    rect(scrX-30, 380, 60, 20);
    if (mousePressed && (new Rect(10, 380, width-20, 20)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
      scrX=mouseX;
      scrX = max(scrX, 40);
      scrX = min(scrX, width-40);
    }
    push();
    if (fullScreenBox.state) {
      if ((10 + (250*(fullResList.buttons.size()/10)))>width)
        fullResList.offset(map(scrX, 40, width-40, 0, width-(10 + (250*((fullResList.buttons.size()/10)+1)))), 0);
      fullResList.render();
    } else {
      if ((10 + (250*(resList.buttons.size()/10)))>width)
        resList.offset(map(scrX, 40, width-40, 0, width-(10 + (250*((resList.buttons.size()/10)+1)))), 0);
      resList.render();
    }
    pop();
    break;
  case LoadLevelPack:
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    text("Jump!", width/2, height/16);
    textSize(subTitleTextSize);
    text("A Platforming Game", width/2, (height/16)+64);
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)-(height/10 + height/20)*2, menuButtonWidth, height/10), width/40, "beginPack", "Main \"Story\"", this, "/levels/defaultPack.savepack")).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)-(height/10 + height/20), menuButtonWidth, height/10), width/40, "setModeClear", "Editor", this, Mode.EditorMenu)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2), menuButtonWidth, height/10), width/40, "setModeClear", "Options", this, Mode.Options)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)+(height/10 + height/20), menuButtonWidth, height/10), width/40, "setMode", "Custom Levels", Mode.SelectFile, Mode.LoadLevelPack)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)+(height/10 + height/20)*2, menuButtonWidth, height/10), width/40, "exit", "Exit Game", this)).render();
    fill(150, 220);
    rect(0, 0, width, height);
    if (saveFilePath == null) {
      setMode(Mode.MainMenu);
      break;
    }
    if (saveFilePath.equals("")) {
      break;
    }
    beginPack(saveFilePath);
    setMode(Mode.MainGame);
    saveFilePath="";
    break;
  case MainMenu:
    story=false;
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    fill(0);
    text("Jump!", width/2, height/16);
    textSize(subTitleTextSize);
    text("A Platforming Game", width/2, (height/16)+64);
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)-(height/10 + height/20)*2, menuButtonWidth, height/10), width/40, "setMode", "Main \"Story\"", this, Mode.LevelSelect, Mode.MainGame)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)-(height/10 + height/20), menuButtonWidth, height/10), width/40, "setModeClear", "Editor", this, Mode.EditorMenu)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2), menuButtonWidth, height/10), width/40, "setModeClear", "Options", this, Mode.Options)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)+(height/10 + height/20), menuButtonWidth, height/10), width/40, "loadPack", "Custom Levels", this)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)+(height/10 + height/20)*2, menuButtonWidth, height/10), width/40, "exit", "Exit Game", this)).render();
    break;
  case Options:
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    fill(0);
    text("Options", width/2, height/16);
    textSize(subTitleTextSize);
    text("A Settings Screen", width/2, (height/16)+64);
    fill(255);
    rect(width/10, height/4, width-width/5, height/16);
    fill(100);
    rect(vol, height/4, width/30, height/16);
    fill(100);
    rect(width/2-width/20, height/4+height/16+height/16, width/10, width/10);
    if (mousePressed && (new Rect(width/10, height/4, width-width/5, height/16)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
      vol=mouseX;
      vol = max(vol, width/10);
      vol = min(vol, width-width/5+width/10-width/30);
    }
    if (click && (new Rect(width/2-width/20, height/4+height/16+height/16, width/10, width/10)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
      float rand = random(1);
      if (rand<0.2f) complete.play();
      else if (rand<0.4f) toggle.play();
      else if (rand<0.6f) death.play();
      else if (rand<0.8f) win.play();
      else button.play();
    }
    float amp = map(vol, width/10, width-width/5+width/10-width/30, 0, 1);
    complete.amp(amp);
    toggle.amp(amp);
    death.amp(amp);
    win.amp(amp);
    button.amp(amp);
    textAlign(LEFT, TOP);
    fill(0);
    text("Volume : " + round(amp*100) +"%", width/10, height/4-height/32);
    settings.setFloat("amp", amp);
    saveJSONObject(settings, "data/settings.json");
    (new Button(new Rect((width/2)-((width/5)/2), height-(height/10)-15, width/5, height/10), width/40, "setModeClear", "Back", this, Mode.MainMenu)).render();
    break;
  case CompletionStats:
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    fill(0);
    text("Stats", width/2, height/16);
    textSize(subTitleTextSize);
    text("For What You Just Did", width/2, (height/16)+64);
    (new Button(new Rect((width/2)-((width/3)/2), height-(height/10)-15, width/3, height/10), width/40, "setModeClear", "Back To Menu", this, Mode.MainMenu)).render();
    textSize(width/20);
    text("Completion Time : " + convertTime(time), width/2, height/3);
    text("Death Count : " + deaths, width/2, height/3+height/3);
    break;
  case LevelSelect:
    //beginPack("/levels/defaultPack.savepack");
    if (levelPack==null) {
      levelPack = loadJSONArray("/levels/defaultPack.savepack");
      story=true;
    }
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    fill(0);
    text("Jump!", width/2, height/16);
    textSize(subTitleTextSize);
    text("Select A Level", width/2, (height/16)+64);
    int ja=0;
    for (int i=0; i<levelPack.size(); i++) {
      rectMode(CENTER);
      ja=floor(i/8);
      boolean hover = false;
      try {
        hover = (new Rect((i%8*width/8 + width/16) - width/20, (ja*(width/8)+height/3) - width/20, width/10, width/10)).isTouching(new Rect(mouseX, mouseY, 1, 1)) && (levelPack.getJSONObject(i-1).getBoolean("completed"));
      }
      catch(Exception e) {
        hover = (new Rect((i%8*width/8 + width/16) - width/20, (ja*(width/8)+height/3) - width/20, width/10, width/10)).isTouching(new Rect(mouseX, mouseY, 1, 1));
      }
      if (hover) {
        fill(150);
        if (mousePressed) {
          fade=200;
          fill(100);
          level = i;
          loadLevel(levelPack.getJSONObject(i));
          setMode(ReturnMode);
          p.levelCooldown=100;
          p.respawn(false);
          time=System.currentTimeMillis();
        }
      } else
        fill(200);
      strokeWeight(1);
      rect(i%8*width/8 + width/16, ja*(width/8)+height/3, width/10, width/10);
      textAlign(CENTER, CENTER);
      fill(0);
      textSize(width/50);
      try {
        text(levelPack.getJSONObject(i).getString("name"), i%8*width/8 + width/16, ja*(width/8)+height/3);
      }
      catch(Exception e) {
        text("Untitled", i%8*width/8 + width/16, ja*(width/8)+height/3);
      }
      try {
        if (!levelPack.getJSONObject(i-1).getBoolean("completed")) {
          fill(100);
          stroke(0);
          rect(i%8*width/8 + width/16, ja*(width/8)+height/3, width/10, width/10);
          fill(150, 0, 0);
          stroke(150, 0, 0);
          strokeWeight(2);
          line((i%8*width/8 + width/16) - width/20, (ja*(width/8)+height/3) - width/20, (i%8*width/8 + width/16) - width/20+width/10, (ja*(width/8)+height/3) - width/20+width/10);
        }
      }
      catch(Exception ignored) {
        println(i);
      }
    }
    rectMode(CORNER);
    break;
  case SelectFile:
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    fill(0);
    text("Select File", width/2, height/16);
    textSize(subTitleTextSize);
    text("A File Browser", width/2, (height/16)+64);
    if (levels==null) {
      File f = new File(sketchPath()+"/levels");
      FilenameFilter filter = new FilenameFilter() {
        @Override
          public boolean accept(File f, String name) {
          return name.endsWith(".save") || name.endsWith(".savepack");
        }
      };
      levels = f.listFiles(filter);
    }
    for (int i=0; i<levels.length; i++) {
      File f = levels[i];
      rectMode(CENTER);
      if ((new Rect(width/2-width/4, i*(height/16)+((height/16)+128)-(height/40), width/2, height/20)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
        fill(150);
        if (mousePressed) {
          fill(100);
          levelPack = loadJSONArray(f.getAbsolutePath());
          setMode(Mode.LevelSelect, ReturnMode);
        }
      } else
        fill(200);
      rect(width/2, i*(height/16)+((height/16)+128), width/2, height/20);
      textAlign(CENTER, CENTER);
      fill(0);
      text(f.getName(), width/2, i*(height/16)+((height/16)+128));
    }
    rectMode(CORNER);
    break;
  case EditorMenu:
    textAlign(CENTER, CENTER);
    textSize(titleTextSize);
    fill(0);
    text("Jump!", width/2, height/16);
    textSize(subTitleTextSize);
    text("The Editor", width/2, (height/16)+64);
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)-(height/10 + 15)*2, menuButtonWidth, height/10), width/40, "beginPack", "Create A Level Pack", this, "default")).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2)-(height/10 + 15), menuButtonWidth, height/10), width/40, "setModeClear", "Create A New Level", this, Mode.LevelEditor)).render();
    (new Button(new Rect((width/2)-(menuButtonWidth/2), (height/2), menuButtonWidth, height/10), width/40, "setMode", "Load A Level/Pack From File", this, Mode.SelectFile, Mode.LevelEditor)).render();
    (new Button(new Rect((width/2)-((width/5)/2), height-(height/10)-15, width/5, height/10), width/40, "setModeClear", "Back", this, Mode.MainMenu)).render();
    break;
  case MainGame:
    if (currentLevel!=null) {
      currentLevel.render(scrollX, scrollY);
      p.render();
      for (Enemy e : enemies) {
        e.render();
        e.AI(p);
      }
      if (p.respawnTimer<=0) {
        for (int i=0; i<100; i++) {
          ArrayList<Tile> tiles = new ArrayList();
          for (int j=0; j<currentLevel.t.length; j++) {
            for (int k=0; k<currentLevel.t[j].length; k++) {
              Tile t = currentLevel.t[j][k];
              t.setHitBox(new Rect(scrollX+(j*tileSize), scrollY+(k*tileSize), tileSize, tileSize));
              if (t.hitBox.isTouching(new Rect(-t.hitBox.w, -t.hitBox.w, width+t.hitBox.w*2, height+t.hitBox.w*2))) {
                tiles.add(t);
              }
            }
          }
          p.updatePhysics(tiles, 100);
        }
      }
      for (Enemy k : kill) {
        enemies.remove(k);
      }
      for (int i=0; i<25; i++) {
        ArrayList<Tile> tiles = new ArrayList();
        for (int j=0; j<currentLevel.t.length; j++) {
          for (int k=0; k<currentLevel.t[j].length; k++) {
            Tile t = currentLevel.t[j][k];
            t.setHitBox(new Rect((j*tileSize), (k*tileSize), tileSize, tileSize));
            if (t.hitBox.isTouching(new Rect(-t.hitBox.w, -t.hitBox.w, width+t.hitBox.w*2, height+t.hitBox.w*2))) {
              tiles.add(t);
            }
          }
        }
        for (Enemy e : enemies) {
          e.updatePhysics(tiles, 50);
        }
      }
      if (!keyPressed)
        key = 'a';
      if (key=='r') {
        p.respawn(false);
      }
    }
    break;
  case EditTile:
    currentLevel.render(scrollX, scrollY, editTile);
    noStroke();
    fill(150, 150);
    rect(width/3+width/3, 0, width/3, height);
    fill(0);
    stroke(0);
    strokeWeight(2);
    line(width/3+width/3, 0, width/3+width/3, height);
    if (editTile.id==12) {
      int c = editTile.text.split("\n").length;
      textSize(height/32);
      if (textWidth(editTile.text.split("\n")[c-1])>width/4) {
        int h = editTile.text.split(" ").length;
        String buf = "";
        if (editTile.text.split("\n")[c-1].split(" ").length==1) {
          buf=editTile.text.substring(0, max(0, editTile.text.length()-1))+"\n"+editTile.text.substring(editTile.text.length()-1);
        } else {
          for (int i = 0; i < h; i++) {
            String s = editTile.text.split(" ")[i];
            if (i==h-1) s = "\n"+s;
            if (i<h-1)
              buf+=s+" ";
            else
              buf+=s;
          }
        }
        editTile.text=buf;
      }
      fill(0, 1);
      rect(width-width/4, height/16, width/4, height/32*c);
      textAlign(TOP, LEFT);
      fill(0);
      text("Text:", (width-width/4)-textWidth("Text: "), height/16+height/32);
      text(editTile.text+((frameCount%60>30)?"|":""), width-width/4, height/16+height/32);
    } else if (editTile.id==14) {
      fill(255);
      rect(width/3+width/3+(width/3-width/4)/2, height/16, width/4, height/32);
      fill(100);
      rect(scrollArb1, height/16, width/30, height/32);
      fill(100);
      if (mousePressed && (new Rect(width/3+width/3+(width/3-width/4)/2, height/16, width/4, height/32)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
        scrollArb1=mouseX;
      }

      fill(255);
      rect(width/3+width/3+(width/3-width/4)/2, height/16*3, width/4, height/32);
      fill(100);
      rect(scrollArb2, height/16*3, width/30, height/32);
      fill(100);
      if (mousePressed && (new Rect(width/3+width/3+(width/3-width/4)/2, height/16*3, width/4, height/32)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
        scrollArb2=mouseX;
      }
      scrollArb1 = max(scrollArb1, width/3+width/3+(width/3-width/4)/2);
      scrollArb1 = min(scrollArb1, width/3+width/3+(width/3-width/4)/2+width/4-width/30);
      scrollArb2 = max(scrollArb2, width/3+width/3+(width/3-width/4)/2);
      scrollArb2 = min(scrollArb2, width/3+width/3+(width/3-width/4)/2+width/4-width/30);
      editTile.limit = (int)map(scrollArb2, width/3+width/3+(width/3-width/4)/2, width/3+width/3+(width/3-width/4)/2+width/4-width/30, 0, 100);
      editTile.spawnDelay = (int)map(scrollArb1, width/3+width/3+(width/3-width/4)/2, width/3+width/3+(width/3-width/4)/2+width/4-width/30, 500, 15000);
      textAlign(LEFT, TOP);
      fill(0);
      text("Spawn Delay : " + nf(editTile.spawnDelay/1000, 2, 1) + "s", width/3+width/3+(width/3-width/4)/2, (height/16)-height/32);
      text("Spawn Limit : " + (editTile.limit==0?"None":editTile.limit), width/3+width/3+(width/3-width/4)/2, (height/16*3)-height/32);
    } else {
      textSize(height/24);
      textAlign(CENTER, CENTER);
      text("No Data To Modify", width-(width/6), height/16);
    }
    break;
  case LevelEditor:
    if (currentLevel==null) {
      if (!saveFilePath.equals("")) {
        levelPack = loadJSONArray(saveFilePath);
        setMode(Mode.LevelSelect, Mode.LevelEditor);
      }
      textAlign(CENTER, CENTER);
      textSize(titleTextSize);
      fill(0);
      text("The Editor!", width/2, height/16);
      textSize(subTitleTextSize);
      text("Please Select Level Dimentions", width/2, (height/16)+64);
      fill(0);
      textAlign(LEFT, CENTER);
      text("Level Width : "+selectedWidth, 10, height/3-20);
      fill(255);
      rect(10, height/3, width-20, 20);
      fill(100);
      rect(map(selectedWidth, 1, 15, 40, width-40)-30, height/3, 60, 20);
      if (mousePressed && (new Rect(10, height/3, width-20, 20)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
        selectedWidth=mouseX;
        selectedWidth = max(selectedWidth, 40);
        selectedWidth = min(selectedWidth, width-40);
        selectedWidth = round(map(selectedWidth, 40, width-40, 1, 15));
      }
      fill(0);
      text("Level Height : "+selectedHeight, 10, height/2-20);
      fill(255);
      rect(10, height/2, width-20, 20);
      fill(100);
      rect(map(selectedHeight, 1, 15, 40, width-40)-30, height/2, 60, 20);
      if (mousePressed && (new Rect(10, height/2, width-20, 20)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
        selectedHeight=mouseX;
        selectedHeight = max(selectedHeight, 40);
        selectedHeight = min(selectedHeight, width-40);
        selectedHeight = round(map(selectedHeight, 40, width-40, 1, 15));
      }
      (new Button(new Rect((width/2)-((width/5)*1.1f), height-(height/10)-15, width/5, height/10), width/40, "setModeClear", "Back", this, Mode.MainMenu)).render();
      (new Button(new Rect((width/2)+((width/5)*1.1f)-(width/5), height-(height/10)-15, width/5, height/10), width/40, "createLevel", "Create Level", this)).render();
      break;
    }
    currentLevel.render(scrollX, scrollY);
    if (arrows[0]==1)scrollY+=tileSize/(8/(arrows[4]+1));
    if (arrows[1]==1)scrollY-=tileSize/(8/(arrows[4]+1));
    if (arrows[2]==1)scrollX-=tileSize/(8/(arrows[4]+1));
    if (arrows[3]==1)scrollX+=tileSize/(8/(arrows[4]+1));
    if (mousePressed) {
      int mx = floor((mouseX-scrollX)/tileSize);
      int my = floor((mouseY-scrollY)/tileSize);
      try {
        if (mouseButton==LEFT) {
          currentLevel.t[mx][my].id = selectedTile;
        }
        if (mouseButton==RIGHT) {
          editTile = currentLevel.t[mx][my];
          setMode(Mode.EditTile);
          scrollArb1 = (int)map(editTile.spawnDelay, 500, 1500, width/3+width/3+(width/3-width/4)/2, width/3+width/3+(width/3-width/4)/2+width/4-width/30);
          scrollArb2 = (int)map(editTile.limit, 0, 100, width/3+width/3+(width/3-width/4)/2, width/3+width/3+(width/3-width/4)/2+width/4-width/30);
        }
      }
      catch(ArrayIndexOutOfBoundsException ignored) {
      }
    }
    if (!keyPressed)
      key = 'a';
    File start1 = new File(sketchPath("")+"/levels/*");
    if (key=='s') {
      key='a';
      GameMode = Mode.SaveLevel;
      saveFilePath="";
      selectInput("Save As", "fileSelected", start1);
    }
    if (key=='l') {
      key='a';
      setMode(Mode.LoadLevel);
      saveFilePath="";
      selectInput("File to Load", "fileSelected", start1);
    }
    break;
  case SaveLevel:
    currentLevel.render(scrollX, scrollY);
    fill(150, 220);
    rect(0, 0, width, height);
    if (saveFilePath == null) {
      setMode(Mode.LevelEditor);
      break;
    }
    if (saveFilePath.equals("")) {
      break;
    }
    JSONObject out = new JSONObject();
    String tiles = "";
    ArrayList<String> text = new ArrayList();
    ArrayList<JSONObject> gen = new ArrayList();
    tiles+=(toBase64(currentLevel.t.length/15));
    tiles+=(toBase64(currentLevel.t[0].length/11));
    tiles+=("?");
    for (int i=0; i<currentLevel.t.length; i++)
      for (int j=0; j<currentLevel.t[i].length; j++) {
        tiles+=(toBase64(currentLevel.t[i][j].id));
        if (currentLevel.t[i][j].id == 12) text.add(currentLevel.t[i][j].text);
        if (currentLevel.t[i][j].id == 14) {
          JSONObject curGen = new JSONObject();
          curGen.setInt("delay", currentLevel.t[i][j].spawnDelay);
          curGen.setInt("limit", currentLevel.t[i][j].limit);
          gen.add(curGen);
        }
      }
    JSONArray textTiles = new JSONArray();
    for (int i=0; i<text.size(); i++) {
      textTiles.setString(i, text.get(i));
    }
    JSONArray gens = new JSONArray();
    for (int i=0; i<gen.size(); i++) {
      gens.setJSONObject(i, gen.get(i));
    }
    out.setString("tiles", tiles);
    out.setJSONArray("text", textTiles);
    out.setJSONArray("generators", gens);
    JSONArray finished = new JSONArray();
    finished.setJSONObject(0, out);
    saveJSONArray(finished, saveFilePath);
    setMode(Mode.LevelEditor);
    break;
  case LoadLevel:
    currentLevel.render(scrollX, scrollY);
    fill(150, 220);
    rect(0, 0, width, height);
    if (saveFilePath == null) {
      setMode(Mode.LevelEditor);
      break;
    }
    if (saveFilePath.equals("")) {
      break;
    }
    loadLevel(loadJSONArray(saveFilePath).getJSONObject(0));
    setMode(ReturnMode);
    break;
  case EditorInventory:
    currentLevel.render(scrollX, scrollY);
    stroke(0);
    strokeWeight(2);
    fill(150, 220);
    rect(40, 40, width-80, height-80);
    (new Button(new Rect(width-60, 20, 40, 40), width/40, "setMode", "X", this, Mode.LevelEditor)).render();
    strokeWeight(1);
    rect(40, 40, width/21, width/21);
    if (selectedTile==0) {
      fill(50);
      rect(40, 40, width/21, width/21);
    }
    if ((new Rect(40, 40, width/21, width/21)).isTouching(new Rect(mouseX, mouseY, 1, 1))) {
      if (mousePressed && mouseButton==LEFT) {
        selectedTile = 0;
      }
    }
    image(eraser, 40, 40, width/21, width/21);

    for (int i=0; i<inventoryTiles.length; i++) {
      for (int j=0; j<inventoryTiles[i].length; j++) {
        Tile t = new Tile(inventoryTiles[i][j]);
        Rect hitBox = new Rect(80+(j*width/18), 120+(i*height/7), width/21, width/21);
        t.setHitBox(hitBox);
        hitBox = new Rect((80-(((width/18)-(width/21))/2))+(j*width/18), (120-(((width/18)-(width/21))/2))+(i*height/7), width/18, width/18);
        if (inventoryTiles[i][j]==selectedTile) {
          fill(50);
          rect(hitBox.x, hitBox.y, hitBox.w, hitBox.h);
        }
        if (hitBox.isTouching(new Rect(mouseX, mouseY, 1, 1))) {
          if (inventoryTiles[i][j]!=selectedTile) {
            fill(75);
            rect(hitBox.x, hitBox.y, hitBox.w, hitBox.h);
          }
          if (mousePressed && mouseButton==LEFT) {
            selectedTile = inventoryTiles[i][j];
            //try {
            //  TimeUnit.MILLISECONDS.sleep(100);
            //}
            //catch(InterruptedException ignored) {
            //}
            //setMode(Mode.LevelEditor);
          }
        }
        t.render(0, 0, true, false, true, true, true, true, true, true);
      }
    }
    if (!keyPressed)
      key = 'a';
    break;
  }
  textSize(15);
  textAlign(LEFT, CENTER);
  fill(255);
  stroke(0);
  text("Version : "+version, width-10-textWidth("Version : "+version), height-15);
  click=false;
  if (fade>100) {
    fill(0, map(fade, 200, 100, 0, 255));
  } else {
    fill(0, map(fade, 100, 0, 255, 0));
  }
  rect(0, 0, width, height);
}

 public void launchGame() {
  GameMode = Mode.MainMenu;
  RadioButton b;
  if (fullScreenBox.state) {
    b = fullResList.activeButton();
  } else {
    b = resList.activeButton();
  }
  String name = b.title;
  int x = Integer.parseInt(name.split("x")[0]);
  int y = Integer.parseInt(name.split("x")[1].split(" \\(")[0]);
  settings.setString("defRes", name);
  settings.setBoolean("fullscreen", fullScreenBox.state);
  saveJSONObject(settings, "data/settings.json");
  surface.setSize(x, y);
  surface.setLocation(displayWidth/2-width/2, displayHeight/2-height/2);
  surface.setTitle("Jump!");
  float amp = settings.getFloat("amp");
  vol = map(amp, 0, 1, width/10, width-width/5+width/10-width/30);
  complete.amp(amp);
  toggle.amp(amp);
  death.amp(amp);
  win.amp(amp);
  button.amp(amp);
  p = new Player(width/2, height/2);
  if (fullScreenBox.state) {
    Frame f = ((SmoothCanvas)surface.getNative()).getFrame();
    f.removeNotify();
    f.setExtendedState(Frame.MAXIMIZED_BOTH);
    f.setUndecorated(true);
    f.setVisible(true);
    f.setLayout(new GridBagLayout());
    f.getGraphics().setColor(Color.BLACK);
    f.getGraphics().fillRect(0, 0, displayWidth, displayHeight);
    ((Graphics2D)f.getGraphics()).scale(2, 2);
    println("Fullscreen");
  }
}

 public void mouseReleased() {
  click=true;
}

 public void beginPack(String lvlPkName) {
  levelPack = loadJSONArray(lvlPkName);
  setModeClear(Mode.LevelSelect);
}

 public void loadLevel(JSONObject obj) {
  enemies.clear();
  JSONArray text = obj.getJSONArray("text");
  JSONArray gen = obj.getJSONArray("generators");
  String code = obj.getString("tiles");
  String[] cc = code.split("\\?");
  String[] loadCode = cc[1].split("");
  String[] dim = cc[0].split("");
  int numText = 0;
  int numGen = 0;
  currentLevel = new Level(fromBase64(dim[0]), fromBase64(dim[1]));
  for (int i=0; i<currentLevel.t.length; i++) {
    for (int j=0; j<currentLevel.t[i].length; j++) {
      try {
        currentLevel.t[i][j].id = fromBase64(loadCode[i * currentLevel.t[i].length  + j]);
      }
      catch(ArrayIndexOutOfBoundsException e) {
        currentLevel.t[i][j].id=1;
      }
      if (currentLevel.t[i][j].id==7) respawnPos = new PVector(i, j);
      if (currentLevel.t[i][j].id==12) {
        currentLevel.t[i][j].text = text.getString(numText);
        numText++;
      }
      if (currentLevel.t[i][j].id==14) {
        currentLevel.t[i][j].spawnDelay = gen.getJSONObject(numGen).getInt("delay");
        currentLevel.t[i][j].limit = gen.getJSONObject(numGen).getInt("limit");
        numGen++;
      }
    }
  }
}

 public void setModeClear(Mode m) {
  scrollArb1=0;
  scrollArb2=0;
  scrollArb3=0;
  ReturnMode = GameMode;
  scrollX=0;
  scrollY=0;
  level=0;
  deaths=0;
  onoffstate=true;
  time=System.currentTimeMillis();
  currentLevel=null;
  p = new Player(width/2, height/2);
  GameMode = m;
}

 public void setMode(Mode m) {
  scrollArb1=0;
  scrollArb2=0;
  scrollArb3=0;
  ReturnMode = GameMode;
  GameMode = m;
}

 public void setMode(Mode m, Mode r) {
  scrollArb1=0;
  scrollArb2=0;
  scrollArb3=0;
  ReturnMode = r;
  GameMode = m;
}

 public void keyPressed() {
  if (keyCode == UP) {
    arrows[0] = 1;
  }
  if (keyCode == DOWN) {
    arrows[1] = 1;
  }
  if (keyCode == RIGHT) {
    arrows[2] = 1;
  }
  if (keyCode == LEFT) {
    arrows[3] = 1;
  }
  if (keyCode == SHIFT) {
    arrows[4] = 1;
  }
  if (key == ESC) {
    if (GameMode == Mode.LevelEditor) {
      int ans = showConfirmDialog(null, "Discard changes?", "Are you sure?", YES_NO_CANCEL_OPTION);
      if (ans==0) {
        setModeClear(Mode.MainMenu);
      }
      if (ans==1) {
        setMode(Mode.SaveLevel);
        selectInput("Save As", "fileSelected");
        fill(150, 220);
        rect(0, 0, width, height);
      }
    }
    if (GameMode == Mode.EditTile) {
      setMode(Mode.LevelEditor);
    }
    if (GameMode == Mode.LevelSelect) {
      setMode(Mode.MainMenu);
    }
    if (GameMode == Mode.SelectFile) {
      setMode(Mode.MainMenu);
    }
    if (GameMode == Mode.MainGame) {
      int ans = showConfirmDialog(null, "Leave game?", "Would you like to return to the main menu?", YES_NO_OPTION);
      if (story) {
        saveJSONArray(levelPack, "levels/defaultPack.savepack");
      }
      story=false;
      if (ans==0) {
        setModeClear(Mode.MainMenu);
      }
    }
    if (GameMode == Mode.EditorInventory) {
      setMode(Mode.LevelEditor);
    }
    key = 0;
    return;
  }
  if (key == 'i') {
    if (GameMode == Mode.LevelEditor) {
      setMode(Mode.EditorInventory);
      return;
    }
    if (GameMode == Mode.EditorInventory) {
      setMode(Mode.LevelEditor);
      return;
    }
    key=' ';
  }
}

 public void loadPack() {
  setMode(Mode.SelectFile, Mode.MainGame);
}

 public void keyReleased() {
  if (keyCode == UP) {
    arrows[0] = 0;
  }
  if (keyCode == DOWN) {
    arrows[1] = 0;
  }
  if (keyCode == RIGHT) {
    arrows[2] = 0;
  }
  if (keyCode == LEFT) {
    arrows[3] = 0;
  }
  if (keyCode == SHIFT) {
    arrows[4] = 0;
  }
}

 public void mouseWheel(MouseEvent event) {
  float e = event.getCount();
  if (GameMode == Mode.LevelEditor)
    tileSize-=e;
  tileSize = (int)max(tileSize, height/33);
  tileSize = (int)min(tileSize, height/(11/1.5f));
}

 public void fileSelected(File selection) {
  if (selection==null) {
    saveFilePath=null;
    return;
  }
  saveFilePath = selection.getAbsolutePath();
}

 public String toBase64(int num) {
  String[] codes = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "F", "G", "H", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "+", "_"};
  if (num<10) {
    return ""+num;
  } else {
    return codes[num-10];
  }
}

 public int fromBase64(String chr) {
  try {
    return Integer.parseInt(chr);
  }
  catch(Exception e) {
    String[] codes = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "F", "G", "H", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "+", "_"};
    return Index.findIndex(codes, chr)+10;
  }
}

 public void createLevel() {
  currentLevel = new Level(selectedWidth, selectedHeight);
}
 public void keyTyped() {
  if (GameMode == Mode.EditTile) {
    if (editTile.id == 12) {
      if (key == BACKSPACE)  editTile.text = editTile.text.substring(0, max(0, editTile.text.length()-1));
      else if (key == ENTER || key == RETURN) editTile.text += "\n";
      else if (key == TAB)  editTile.text += "    ";
      else if (key == DELETE)  editTile.text = "";
      else if (key >= ' ')     editTile.text += str(key);
    }
  }
}

 public String convertTime(long start) {
  long millis = end-start;
  int minutes = floor(millis/1000/60);
  millis-=minutes*1000*60;
  int seconds = floor(millis/1000);
  millis-=seconds*1000;
  return nf(minutes, 2)+":"+nf(seconds, 2)+"."+nf((int)millis, 4);
}

class Button {
  Rect boundingBox;
  Method callback;
  Object main;
  String title;
  Object[] args = new Object[0];
  int forcedTextSize = 0;

  public Button(Rect r, String callback, String title, Object main) {
    this.boundingBox=r;
    this.title=title;
    this.main=main;
    try {
      Class c = Class.forName(getCallerClassName());
      this.callback = c.getMethod(callback);
    }
    catch(ClassNotFoundException ignored) {
    }
    catch (NoSuchMethodException e) {
      //handle if method isn't found
    }
  }

  public Button(Rect r, int forcedTextSize, String callback, String title, Object main) {
    this.boundingBox=r;
    this.title=title;
    this.main=main;
    this.forcedTextSize = forcedTextSize;
    try {
      Class c = Class.forName(getCallerClassName());
      this.callback = c.getMethod(callback);
    }
    catch(ClassNotFoundException ignored) {
    }
    catch (NoSuchMethodException e) {
      //handle if method isn't found
    }
  }

  public Button(Rect r, int forcedTextSize, String callback, String title, Object main, Object... args) {
    this.boundingBox=r;
    this.title=title;
    this.main=main;
    this.args=args;
    this.forcedTextSize = forcedTextSize;
    try {
      Class c = Class.forName(getCallerClassName());
      Class[] types = new Class[args.length];
      for (int i=0; i<args.length; i++) {
        types[i] = args[i].getClass();
      }
      this.callback = c.getMethod(callback, types);
    }
    catch(ClassNotFoundException ignored) {
    }
    catch (NoSuchMethodException e) {
      //handle if method isn't found
    }
  }

  public Button(Rect r, String callback, String title, Object main, Object... args) {
    this.boundingBox=r;
    this.title=title;
    this.main=main;
    this.args=args;
    try {
      Class c = Class.forName(getCallerClassName());
      Class[] types = new Class[args.length];
      for (int i=0; i<args.length; i++) {
        types[i] = args[i].getClass();
      }
      this.callback = c.getMethod(callback, types);
    }
    catch(ClassNotFoundException ignored) {
    }
    catch (NoSuchMethodException e) {
      //handle if method isn't found
    }
  }

  public void render() {
    push();
    fill((new Rect(mouseX, mouseY, 1, 1)).isTouching(boundingBox)?((mousePressed)?150:200):255);
    rect(boundingBox.x, boundingBox.y, boundingBox.w, boundingBox.h, 10);
    for (int i=1; i<100; i++) {
      textSize(i);
      if (textWidth(title) >= boundingBox.w) {
        textSize(i-3);
        break;
      }
    }
    if (forcedTextSize!=0) textSize(forcedTextSize);
    fill(0);
    textAlign(CENTER, CENTER);
    text(title, boundingBox.x+(boundingBox.w/2), boundingBox.y+(boundingBox.h/2));
    pop();
    if (click && (new Rect(mouseX, mouseY, 1, 1)).isTouching(boundingBox)) {
      button.play();
      try {
        if (this.args!=null) {
          this.callback.invoke(this.main, this.args);
        } else {
          this.callback.invoke(this.main);
        }
      }
      catch(IllegalAccessException e) {
        e.printStackTrace();
      }
      catch(InvocationTargetException e) {
        e.printStackTrace();
      }
      catch(NullPointerException e) {
        e.printStackTrace();
      }
    }
  }

  private String getCallerClassName() {
    StackTraceElement[] stElements = Thread.currentThread().getStackTrace();
    for (int i=1; i<stElements.length; i++) {
      StackTraceElement ste = stElements[i];
      if (!ste.getClassName().equals(Button.class.getName()) && ste.getClassName().indexOf("java.lang.Thread")!=0) {
        return ste.getClassName();
      }
    }
    return null;
  }
}

class RadioButton {
  Rect boundingBox;
  Boolean state = false;
  String title;
  long enableTime;

  public RadioButton(Rect r, String title) {
    this.boundingBox=r;
    this.title=title;
  }

  public RadioButton(Rect r, String title, boolean def) {
    this.boundingBox=r;
    this.title=title;
    if (def) {
      state = true;
      enableTime = System.currentTimeMillis();
    }
  }

  public void render() {
    pushStyle();
    textSize(20);
    fill(((new Rect(mouseX, mouseY, 1, 1)).isTouching(boundingBox)/* || this.state*/)?200:255);
    ellipseMode(CENTER);
    ellipse(boundingBox.x+10, boundingBox.y+(boundingBox.h/2), 15, 15);
    if (this.state) {
      fill(0);
      ellipse(boundingBox.x+10, boundingBox.y+(boundingBox.h/2), 5, 5);
    }
    fill(0);
    textAlign(LEFT, CENTER);
    text(title, boundingBox.x+35, boundingBox.y+(boundingBox.h/2)-2);
    popStyle();
    if (click && (new Rect(mouseX, mouseY, 1, 1)).isTouching(boundingBox)) {
      button.play();
      this.state = !this.state;
      if (this.state) this.enableTime = System.currentTimeMillis();
    }
  }
}

class CheckBox {
  Rect boundingBox;
  Boolean state = false;
  String title;
  long enableTime;

  public CheckBox(Rect r, String title) {
    this.boundingBox=r;
    this.title=title;
  }

  public CheckBox(Rect r, String title, boolean def) {
    this.boundingBox=r;
    this.title=title;
    if (def) {
      state = true;
      enableTime = System.currentTimeMillis();
    }
  }

  public void render() {
    pushStyle();
    textSize(20);
    fill(((new Rect(mouseX, mouseY, 1, 1)).isTouching(boundingBox)/* || this.state*/)?200:255);
    rectMode(CENTER);
    rect(boundingBox.x+10, boundingBox.y+(boundingBox.h/2), 15, 15);
    if (this.state) {
      fill(0);
      rect(boundingBox.x+10, boundingBox.y+(boundingBox.h/2), 5, 5);
    }
    fill(0);
    textAlign(LEFT, CENTER);
    text(title, boundingBox.x+35, boundingBox.y+(boundingBox.h/2)-2);
    popStyle();
    if (click && (new Rect(mouseX, mouseY, 1, 1)).isTouching(boundingBox)) {
      button.play();
      this.state = !this.state;
      if (this.state) this.enableTime = System.currentTimeMillis();
    }
  }
}

class RadioButtonList {
  ArrayList<RadioButton> buttons = new ArrayList();

  public RadioButtonList() {
  }

  public void add(RadioButton button) {
    buttons.add(button);
  }

  public void render() {
    RadioButton win = new RadioButton(new Rect(0, 0, 0, 0), "");
    long winTime = 0;
    for (RadioButton b : buttons) {
      if (winTime<b.enableTime) {
        winTime = b.enableTime;
        win = b;
      }
    }
    for (RadioButton b : buttons) {
      if (b != win) {
        b.state=false;
      } else {
        push();
        fill(0, 0);
        stroke(0);
        rect(b.boundingBox.x, b.boundingBox.y, b.boundingBox.w, b.boundingBox.h);
        pop();
      }
      b.render();
    }
  }

  public RadioButton activeButton() {
    for (RadioButton b : buttons) {
      if (b.state) return b;
    }
    return null;
  }

  public void offset(float x, float y) {
    for (RadioButton b : buttons) {
      b.boundingBox.x = b.boundingBox.defx + x;
      b.boundingBox.y = b.boundingBox.defy + y;
    }
  }
}
class Enemy {
  PVector pos;
  PVector vel;
  Rect upHit, leftHit, downHit, rightHit;
  int[] standAble = {1, 2, 3, 4, 5, 6};
  int jumpTimer = 0;
  byte[] arrows = new byte[4];
  boolean canToggle = false;

  public Enemy(float x, float y) {
    pos = new PVector(x, y);
    vel = new PVector(0, 0);
  }

  public void render() {
    fill(255,0,0);
    stroke(0);
    float size=tileSize/2;
    rect(pos.x-(size/2)+scrollX, pos.y-(size/2)+scrollY, size, size);
  }

  public void spawn(float x, float y) {
    pos.x = x;
    pos.y = y;
    this.vel = new PVector(0, 0);
  }

  public void AI(Player p) {
    if (p.pos.x<this.pos.x) {
      this.arrows[3]=1;
      this.arrows[2]=0;
    }
    if (p.pos.x>this.pos.x) {
      this.arrows[3]=0;
      this.arrows[2]=1;
    }
    if (p.pos.y<this.pos.y) {
      this.arrows[0]=1;
    }
    if (p.pos.y>this.pos.y) {
      this.arrows[0]=0;
    }
  }

  public void updatePhysics(ArrayList<Tile> collide, int timeStep) {
    if (this.pos.y>(currentLevel.t[0].length*tileSize)) kill.add(this);
    jumpTimer--;
    jumpTimer = max(jumpTimer, 0);
    upHit = new Rect(pos.x-(tileSize/4)+(tileSize/9), pos.y-(tileSize/4), tileSize/2-(tileSize/9)*2, tileSize/9);
    downHit = new Rect(pos.x-(tileSize/4)+(tileSize/9), pos.y-(tileSize/4)+(tileSize/2)-(tileSize/9), tileSize/2-(tileSize/9)*2, tileSize/9);
    leftHit = new Rect(pos.x-(tileSize/4), pos.y-(tileSize/4)+(tileSize/9), tileSize/9, tileSize/2-(tileSize/9)*2);
    rightHit = new Rect(pos.x-(tileSize/4)+(tileSize/2)-(tileSize/9), pos.y-(tileSize/4)+(tileSize/9), tileSize/9, tileSize/2-(tileSize/9)*2);
    Tile rightTouch = new Tile(-1), leftTouch = new Tile(-1), downTouch = new Tile(-1), upTouch = new Tile(-1);
    for (Tile t : collide) {
      if (upHit.isTouching(t.hitBox) && t.isSolid()) upTouch=t;
      if (downHit.isTouching(t.hitBox) && t.isSolid()) downTouch=t;
      if (leftHit.isTouching(t.hitBox) && t.isSolid()) leftTouch=t;
      if (rightHit.isTouching(t.hitBox) && t.isSolid()) rightTouch=t;
    }
    if (debug) {
      fill(255);
      if (upTouch.hitBox!=null) upTouch.hitBox.render();
      fill(255, 0, 0);
      if (downTouch.hitBox!=null) downTouch.hitBox.render();
      fill(0, 255, 0);
      if (leftTouch.hitBox!=null) leftTouch.hitBox.render();
      fill(0, 0, 255);
      if (rightTouch.hitBox!=null) rightTouch.hitBox.render();
    }

    if (upTouch.id == 6 || downTouch.id == 6 || leftTouch.id == 6 || rightTouch.id == 6) {
      timeStep*=1.5f;
    }

    if (jumpTimer==0) {
      if (downTouch.id == 6 || downTouch.id==3) {
        if (this.arrows[0]==1) {
          this.vel.set(new PVector(this.vel.x, (-tileSize/(5f*1.5f))));
          jumpTimer=1000;
        }
      }
      if (downTouch.isSolid()) {
        if (this.arrows[0]==0) {
          if (downTouch.id==4) {
            this.vel.set(new PVector(this.vel.x, this.vel.y*-0.66f));
          } else {
            this.vel.set(new PVector(this.vel.x, 0));
          }
        } else {
          if (upTouch.id == 6 || downTouch.id == 6 || leftTouch.id == 6 || rightTouch.id == 6) {
            this.vel.set(new PVector(this.vel.x, (-tileSize/(5f*1.5f))));
          } else {
            if (downTouch.id==4) {
              this.vel.set(new PVector(this.vel.x, (-tileSize/3f)));
            } else {
              this.vel.set(new PVector(this.vel.x, (-tileSize/4f)));
            }
          }
          jumpTimer=2000;
        }
      } else {
        this.vel.add(new PVector(0, (tileSize/64f/timeStep)));
      }
    } else {
      jumpTimer--;
    }

    if (upTouch.isCollidable()) {
      if (upTouch.id==9 && canToggle) {
        onoffstate = !onoffstate;
        toggle.play();
      }
      canToggle=false;
      float dist = (upTouch.hitBox.y+upTouch.hitBox.h)-upHit.y;
      this.vel.set(new PVector(this.vel.x, dist));
      this.vel.add(new PVector(0, 0.01f));
    } else {
      canToggle=true;
    }

    if (this.arrows[3]==1) {
      this.vel.add(new PVector(-tileSize/1024f, 0));
    }

    if (this.arrows[2]==1) {
      this.vel.add(new PVector(tileSize/1024f, 0));
    }

    if (rightTouch.isCollidable()) {
      if (this.arrows[3]==0) {
        if (jumpTimer==0 || this.vel.x>=-1e-5f)
          this.vel.set(new PVector(0, this.vel.y));
        else if (jumpTimer>0)
          this.vel.set(new PVector(-tileSize, this.vel.y));
      } else {
        this.vel.add(new PVector(-tileSize/512f, 0));
      }
      if (this.arrows[0]==1&&jumpTimer==0) {
        this.vel.set(new PVector(-tileSize/512f, (-tileSize/5f)));
        jumpTimer=2000;
      }
    }

    if (leftTouch.isCollidable()) {
      if (this.arrows[2]==0) {
        if (jumpTimer==0 || this.vel.x<=1e-5f)
          this.vel.set(new PVector(0, this.vel.y));
        else if (jumpTimer>0)
          this.vel.set(new PVector(tileSize, this.vel.y));
      } else {
        this.vel.add(new PVector(tileSize/512f, 0));
      }
      if (this.arrows[0]==1&&jumpTimer==0) {
        this.vel.set(new PVector(tileSize/512f, (-tileSize/5f)));
        jumpTimer=2000;
      }
    }

    if (upTouch.isCollidable()) {
      float dist = (upTouch.hitBox.y+upTouch.hitBox.h)-upHit.y;
      this.vel.set(new PVector(this.vel.x, dist));
      this.vel.add(new PVector(0, 0.01f));
    }
    if (upTouch.id == 6 || downTouch.id == 6 || leftTouch.id == 6 || rightTouch.id == 6) {
      this.vel.x*=0.90f;
    } else {
      this.vel.x*=0.99f;
    }
    this.pos.y += this.vel.y/timeStep;
    this.pos.x += this.vel.x/timeStep;
    for (Tile t : collide) {
      if (upHit.isTouching(t.hitBox) && t.isCollidable() && upTouch.id == -1) upTouch=t;
      if (downHit.isTouching(t.hitBox) && t.isCollidable() && downTouch.id == -1) downTouch=t;
      if (leftHit.isTouching(t.hitBox) && t.isCollidable() && leftTouch.id== -1) leftTouch=t;
      if (rightHit.isTouching(t.hitBox) && t.isCollidable() && rightTouch.id == -1) rightTouch=t;
    }

    if (upTouch.id == 3 || downTouch.id == 3 || leftTouch.id == 3 || rightTouch.id == 3) {
      kill.add(this);
    }

    if (debug) {
      fill(255);
      rect(upHit.x+scrollX, upHit.y+scrollY, upHit.w, upHit.h);
      fill(255, 0, 0);
      rect(downHit.x+scrollX, downHit.y+scrollY, downHit.w, downHit.h);
      fill(0, 255, 0);
      rect(leftHit.x+scrollX, leftHit.y+scrollY, leftHit.w, leftHit.h);
      fill(0, 0, 255);
      rect(rightHit.x+scrollX, rightHit.y+scrollY, rightHit.w, rightHit.h);
    }
  }
}

class GameCanvas extends PGraphics {
  public GameCanvas(PApplet main) {
    super();
    setParent(main);
    setPrimary(false);
    setSize(width, height);
    textFont(gameFont);
  }

  public void update() {
    
  }
}
class Level {
  Tile[][] t;
  public Level(Boolean... code) {
  }


  public Level(int scrX, int scrY) {
    t = new Tile[scrX*15][scrY*11];
    for (int i=0; i<scrX*15; i++) {
      for (int j=0; j<scrY*11; j++) {
        if (i==0||j==0||i==scrX*15-1||j==scrY*11-1)
          t[i][j]= new Tile(1);
        else
          t[i][j]= new Tile(0);
      }
    }
  }

  public void render(float x, float y, Tile... highlight) {
    for (int i=0; i<t.length; i++) {
      for (int j=0; j<t[i].length; j++) {
        int[] visible = {1, 2, 4, 5, 9, 1, 1};
        if (t[i][j].id!=1) {
          visible[5]=3;
          visible[6]=6;
        }
        t[i][j].setHitBox(new Rect(x+(i*tileSize), y+(j*tileSize), tileSize, tileSize));
        Boolean[] b = new Boolean[12];
        if (i==0||j==0)b[0]=true;
        else if (Index.findIndex(visible, t[i-1][j-1].id)!=-1)b[0]=true;
        else b[0]=false;

        if (j==0)b[1]=true;
        else if (Index.findIndex(visible, t[i][j-1].id)!=-1)b[1]=true;
        else b[1]=false;

        if (i==t.length-1||j==0)b[2]=true;
        else if (Index.findIndex(visible, t[i+1][j-1].id)!=-1)b[2]=true;
        else b[2]=false;

        if (i==t.length-1)b[3]=true;
        else if (Index.findIndex(visible, t[i+1][j].id)!=-1)b[3]=true;
        else b[3]=false;

        if (i==t.length-1||j==t[i].length-1)b[4]=true;
        else if (Index.findIndex(visible, t[i+1][j+1].id)!=-1)b[4]=true;
        else b[4]=false;

        if (j==t[i].length-1)b[5]=true;
        else if (Index.findIndex(visible, t[i][j+1].id)!=-1)b[5]=true;
        else b[5]=false;

        if (i==0||j==t[i].length-1)b[6]=true;
        else if (Index.findIndex(visible, t[i-1][j+1].id)!=-1)b[6]=true;
        else b[6]=false;

        if (i==0)b[7]=true;
        else if (Index.findIndex(visible, t[i-1][j].id)!=-1)b[7]=true;
        else b[7]=false;

        if (i==0)b[8]=true;
        else if (t[i-1][j].id==3)b[8]=true;
        else b[8]=false;

        if (i==t.length-1)b[9]=true;
        else if (t[i+1][j].id==3)b[9]=true;
        else b[9]=false;

        if (i==0)b[10]=true;
        else if (t[i-1][j].id==6)b[10]=true;
        else b[10]=false;

        if (i==t.length-1)b[11]=true;
        else if (t[i+1][j].id==6)b[11]=true;
        else b[11]=false;

        t[i][j].render(i, j, b);
      }
    }
    for (int i=0; i<t.length; i++) {
      for (int j=0; j<t[i].length; j++) {
        for (Tile tile : highlight) {
          if (t[i][j]==tile) {
            noFill();
            stroke(255);
            strokeWeight(2);
            rect(t[i][j].hitBox.x, t[i][j].hitBox.y, t[i][j].hitBox.w, t[i][j].hitBox.w);
            strokeWeight(1);
          }
        }
      }
    }
  }
}

class Tile {
  int id = 0;
  Rect hitBox;
  float angle = 0;
  String text = "";
  long timer = 0;
  int limit=3;
  int spawned=0;
  int spawnDelay=1000;

  public Tile(int id) {
    this.id=id;
  }

  public void setHitBox(Rect r) {
    this.hitBox=r;
  }

  public boolean isCollidable() {
    int[] colliding = {1, 4, 5, 9, 1, 3, 6, 2};
    if (onoffstate) {
      colliding[4]=10;
    } else {
      colliding[4]=11;
    }
    return Index.findIndex(colliding, id)!=-1;
  }

  public boolean isSolid() {
    int[] colliding = {1, 4, 5, 9, 1, 2};
    if (onoffstate) {
      colliding[4]=10;
    } else {
      colliding[4]=11;
    }
    return Index.findIndex(colliding, id)!=-1;
  }

  public void render(int x, int y, Boolean... surrounded) {
    noStroke();
    if (!hitBox.isTouching(new Rect(-hitBox.w, -hitBox.w, width+hitBox.w*2, height+hitBox.w*2)))
      return;
    push();
    translate(hitBox.x+hitBox.w/2, hitBox.y+hitBox.w/2);
    rotate(angle);
    translate(-hitBox.w/2, -hitBox.w/2);
    switch(this.id) {
      case(0):
      break;
      case(1):
      fill(0);
      /*
       0 - tl
       1 - t
       2 - tr
       3 - r
       4 - br
       5 - b
       6 - bl
       7 - l
       8 - Lava Left
       9 - Lava Right
       10 - Water Left
       11 - Water Right
       */
      if (surrounded.length>0) {
        if (surrounded.length>8)
          if (surrounded[8]|surrounded[10]) {
            if (surrounded[8]) fill(0xFFFF0000);
            else  fill(0xFF0A67FF);
            if (!surrounded[1]) {
              beginShape();
              vertex(hitBox.w/2, hitBox.w);
              vertex(0, hitBox.w);
              for (int i=0; i<15; i+=1) {
                float off=0;
                vertex(
                  map(i, 0, 14, 0, hitBox.w/2), (off+ sin((hitBox.x+map(i, 0, 14, 0, hitBox.w/2))/5+frameCount/5f)+1)*5);
              }
              endShape();
            }
          }
        if (surrounded.length>8)
          if (surrounded[9]|surrounded[11]) {
            if (surrounded[9]) fill(0xFFFF0000);
            else  fill(0xFF0A67FF);
            if (!surrounded[1]) {
              beginShape();
              vertex(hitBox.w, hitBox.w);
              vertex(hitBox.w/2, hitBox.w);
              for (int i=0; i<15; i+=1) {
                float off=0;
                vertex(
                  map(i, 0, 14, hitBox.w/2, hitBox.w), (off+ sin((hitBox.x+map(i, 0, 14, hitBox.w/2, hitBox.w))/5+frameCount/5f)+1)*5);
              }
              endShape();
            }
          }
        fill(0);
        rect(0, 0, hitBox.w, hitBox.w, (!surrounded[0] && !surrounded[7] && !surrounded[1])?15:0, (!surrounded[2] && !surrounded[3] && !surrounded[1])?15:0, (!surrounded[4] && !surrounded[5] && !surrounded[3])?15:0, (!surrounded[6] && !surrounded[5] && !surrounded[7])?15:0);
      } else {
        rect(0, 0, hitBox.w, hitBox.w);
      }
      fill(100);
      noStroke();
      int num = 16;
      break;
      case(2):
      fill(255, 255, 0);
      rect(0, 0, hitBox.w, hitBox.w);
      break;
      case(3):
      fill(255, 0, 0);
      if (surrounded.length>0) {
        if (!surrounded[1]) {
          beginShape();
          vertex(hitBox.w, hitBox.w);
          vertex(0, hitBox.w);
          for (int i=0; i<31; i+=1) {
            float off=0;
            vertex(
              map(i, 0, 30, 0, hitBox.w), (off+ sin((hitBox.x+map(i, 0, 30, 0, hitBox.w))/5+frameCount/5f)+1)*5);
          }
          endShape();
          break;
        }
      }
      rect(0, 0, hitBox.w, hitBox.w);
      break;
      case(4):
      fill(0xFF1BDE22);
      rect(0, 0, hitBox.w, hitBox.w);
      break;
      case(5):
      fill(0xFF1B67DE);
      rect(0, 0, hitBox.w, hitBox.w);
      break;
      case(6):
      fill(0xFF0A67FF);
      if (surrounded.length>0) {
        if (!surrounded[1]) {
          beginShape();
          vertex(hitBox.w, hitBox.w);
          vertex(0, hitBox.w);
          for (int i=0; i<31; i+=1) {
            float off=0;
            vertex(
              map(i, 0, 30, 0, hitBox.w), (off+ sin((hitBox.x+map(i, 0, 30, 0, hitBox.w))/5+frameCount/5f)+1)*5);
          }
          endShape();
          break;
        }
      }
      rect(0, 0, hitBox.w, hitBox.w);
      break;
      case(7):
      if (GameMode!=Mode.LevelEditor && GameMode!=Mode.EditorInventory) {
        pop();
        return;
      }
      fill(0xFF946E9D);
      rect(0, 0, hitBox.w, hitBox.w);
      fill(0);
      textAlign(CENTER, CENTER);
      textSize(hitBox.w/2);
      text("S", hitBox.w/2, hitBox.w/2);
      break;
      case(8):
      if (GameMode!=Mode.LevelEditor && GameMode!=Mode.EditorInventory) {
        pop();
        return;
      }
      fill(0xFF946E9D);
      rect(0, 0, hitBox.w, hitBox.w);
      fill(0);
      textAlign(CENTER, CENTER);
      textSize(hitBox.w/2);
      text("C", hitBox.w/2, hitBox.w/2);
      break;
      case(9):
      stroke(0);
      strokeWeight(3);
      if (onoffstate) {
        fill(0xFF7502A0);
        rect(0, 0, hitBox.w, hitBox.w);
        fill(0);
        textAlign(CENTER, CENTER);
        textSize(hitBox.w/2);
        text("ON", hitBox.w/2, hitBox.w/2);
      } else {
        fill(0xFF1A78D3);
        rect(0, 0, hitBox.w, hitBox.w);
        fill(0);
        textAlign(CENTER, CENTER);
        textSize(hitBox.w/2);
        text("OFF", hitBox.w/2, hitBox.w/2);
      }
      break;
      case(10):
      stroke(0);
      strokeWeight(3);
      if (onoffstate) {
        fill(0xFF7502A0);
        rect(0, 0, hitBox.w, hitBox.w);
      } else {
        stroke(0xFF7502A0);
        fill(0, 0);
        rect(0, 0, hitBox.w, hitBox.w);
      }
      break;
      case(11):
      stroke(0);
      strokeWeight(3);
      if (!onoffstate) {
        fill(0xFF1A78D3);
        rect(0, 0, hitBox.w, hitBox.w);
      } else {
        stroke(0xFF1A78D3);
        fill(0, 0);
        rect(0, 0, hitBox.w, hitBox.w);
      }
      break;
      case(12):
      textAlign(LEFT, CENTER);
      if (text.equalsIgnoreCase("")) {
        fill(100);
        textSize(tileSize/3);
        text("ABC...", 0, hitBox.w/2);
        break;
      }
      fill(0);
      textSize(tileSize/3);
      text(this.text, 0, hitBox.w/2);
      break;
      case(13):
      fill(0xFF0A67FF);
      if (surrounded.length>0) {
        if (!surrounded[1]) {
          beginShape();
          vertex(hitBox.w, hitBox.w);
          vertex(0, hitBox.w);
          for (int i=0; i<31; i+=1) {
            float off=0;
            vertex(
              map(i, 0, 30, 0, hitBox.w), ((off+ sin((hitBox.x+map(i, 0, 30, 0, hitBox.w))/5+frameCount/5f)+1)*5)+((hitBox.w/3)*2));
          }
          endShape();
          break;
        }
      }
      rect(0, 0, hitBox.w, hitBox.w);
      break;
      case(14):
      if (limit==0) spawned=-1;
      if (timer+spawnDelay<System.currentTimeMillis() && GameMode == Mode.MainGame && spawned < limit) {
        Enemy e = new Enemy(0, 0);
        e.spawn(x*tileSize, y*tileSize);
        enemies.add(e);
        timer=System.currentTimeMillis();
        spawned++;
      }
      if (GameMode!=Mode.LevelEditor && GameMode!=Mode.EditorInventory) {
        pop();
        return;
      }
      fill(0xFF946E9D);
      rect(0, 0, hitBox.w, hitBox.w);
      fill(0);
      textAlign(CENTER, CENTER);
      textSize(hitBox.w/2);
      text("G", hitBox.w/2, hitBox.w/2);
      break;
    }
    //fill(0);
    //textAlign(CENTER, CENTER);
    //textSize(hitBox.w/2);
    //text(this.id, hitBox.w/2, hitBox.w/2);
    pop();
  }
}

public static class Index {

  // Linear-search function to find the index of an element
  public static int findIndex(Object arr[], Object t)
  {

    // if array is Null
    if (arr == null) {
      return -1;
    }

    // find length of array
    int len = arr.length;
    int i = 0;

    // traverse in the array
    while (i < len) {

      // if the i-th element is t
      // then return the index
      if (arr[i].equals(t)) {
        return i;
      } else {
        i = i + 1;
      }
    }
    return -1;
  }

  public static int findIndex(int arr[], int t)
  {

    // if array is Null
    if (arr == null) {
      return -1;
    }

    // find length of array
    int len = arr.length;
    int i = 0;

    // traverse in the array
    while (i < len) {

      // if the i-th element is t
      // then return the index
      if (arr[i] == t) {
        return i;
      } else {
        i = i + 1;
      }
    }
    return -1;
  }
}

static enum Mode {
  Launcher,
    MainMenu,
    MainGame,
    EditorMenu,
    LevelEditor,
    EditorInventory,
    Options,
    SaveLevel,
    LoadLevel,
    LoadLevelPack,
    SelectFile,
    CompletionStats,
    EditTile,
    LevelSelect,
}
class Player {
  PVector pos;
  PVector vel;
  Rect upHit, leftHit, downHit, rightHit;
  int[] standAble = {1, 2, 3, 4, 5, 6};
  int jumpTimer = 0;
  boolean canToggle = false;
  float respawnTimer = 0;
  float levelCooldown = 0;

  public Player(float x, float y) {
    pos = new PVector(x, y);
    vel = new PVector(0, 0);
  }

  public void render() {
    levelCooldown--;
    fill(51);
    stroke(0);
    float size=tileSize/2;
    if (respawnTimer>0) {
      size = map(respawnTimer, 100, 0, tileSize/2, 0);
    }
    rect(width/2-(size/2), height/2-(size/2), size, size);
    if (respawnTimer==1) {
      loadLevel(levelPack.getJSONObject(level));
      println("Respawning...");
      onoffstate=true;
      pos.x = respawnPos.x;
      pos.y = respawnPos.y;
      pos.mult(tileSize);
      pos.x+=tileSize/2;
      pos.y+=tileSize-(tileSize/4);
      this.vel = new PVector(0, 0);
      respawnTimer--;
    } else {
      respawnTimer-=3;
    }
  }

  public void respawn(boolean ded) {
    if (godMode && ded) return;
    fade=200;
    respawnTimer = 100;
    if (ded) {
      deaths++;
      death.stop();
      death.play();
    }
  }

  public void updatePhysics(ArrayList<Tile> collide, int timeStep) {
    if (this.pos.y>(currentLevel.t[0].length*tileSize) && respawnTimer<=0) respawn(true);
    scrollX=-pos.x+(width/2);
    scrollY=-pos.y+(height/2);
    jumpTimer--;
    jumpTimer = max(jumpTimer, 0);
    upHit = new Rect(width/2-(tileSize/4)+(tileSize/9), height/2-(tileSize/4), tileSize/2-(tileSize/9)*2, tileSize/9);
    downHit = new Rect(width/2-(tileSize/4)+(tileSize/9), height/2-(tileSize/4)+(tileSize/2)-(tileSize/9), tileSize/2-(tileSize/9)*2, tileSize/9);
    leftHit = new Rect(width/2-(tileSize/4), height/2-(tileSize/4)+(tileSize/9), tileSize/9, tileSize/2-(tileSize/9)*2);
    rightHit = new Rect(width/2-(tileSize/4)+(tileSize/2)-(tileSize/9), height/2-(tileSize/4)+(tileSize/9), tileSize/9, tileSize/2-(tileSize/9)*2);
    Tile rightTouch = new Tile(-1), leftTouch = new Tile(-1), downTouch = new Tile(-1), upTouch = new Tile(-1);
    for (Tile t : collide) {
      if (upHit.isTouching(t.hitBox) && t.isSolid()) upTouch=t;
      if (downHit.isTouching(t.hitBox) && t.isSolid()) downTouch=t;
      if (leftHit.isTouching(t.hitBox) && t.isSolid()) leftTouch=t;
      if (rightHit.isTouching(t.hitBox) && t.isSolid()) rightTouch=t;
    }
    if (debug) {
      fill(255);
      if (upTouch.hitBox!=null) upTouch.hitBox.render();
      fill(255, 0, 0);
      if (downTouch.hitBox!=null) downTouch.hitBox.render();
      fill(0, 255, 0);
      if (leftTouch.hitBox!=null) leftTouch.hitBox.render();
      fill(0, 0, 255);
      if (rightTouch.hitBox!=null) rightTouch.hitBox.render();
    }

    if (upTouch.id == 6 || downTouch.id == 6 || leftTouch.id == 6 || rightTouch.id == 6) {
      timeStep*=1.5f;
    }

    if ((upTouch.id == 2 || downTouch.id == 2 || leftTouch.id == 2 || rightTouch.id == 2) && levelCooldown<=0) {
      levelCooldown = 50;
      levelPack.getJSONObject(level).setBoolean("completed", true);
      level++;
      if (level>=levelPack.size()) {
        if (story) {
          saveJSONArray(levelPack, "levels/defaultPack.savepack");
        }
        complete.stop();
        complete.play();
        end = System.currentTimeMillis();
        setMode(Mode.CompletionStats);
        return;
      }
      win.stop();
      win.play();
      respawn(false);
    }

    if (jumpTimer==0) {
      if (downTouch.id == 6 || downTouch.id==3) {
        if (arrows[0]==1) {
          this.vel.set(new PVector(this.vel.x, (-tileSize/(5f*1.5f))));
          jumpTimer=1000;
        }
      }
      if (downTouch.isSolid()) {
        if (arrows[0]==0) {
          if (downTouch.id==4) {
            this.vel.set(new PVector(this.vel.x, this.vel.y*-0.66f));
          } else {
            this.vel.set(new PVector(this.vel.x, 0));
          }
        } else {
          if (upTouch.id == 6 || downTouch.id == 6 || leftTouch.id == 6 || rightTouch.id == 6) {
            this.vel.set(new PVector(this.vel.x, (-tileSize/(5f*1.5f))));
          } else {
            if (downTouch.id==4) {
              this.vel.set(new PVector(this.vel.x, (-tileSize/3f)));
            } else {
              this.vel.set(new PVector(this.vel.x, (-tileSize/4f)));
            }
          }
          jumpTimer=2000;
        }
      } else {
        this.vel.add(new PVector(0, (tileSize/64f/timeStep)));
      }
    } else {
      jumpTimer--;
    }


    if (arrows[3]==1) {
      this.vel.add(new PVector(-tileSize/512f, 0));
    }

    if (arrows[2]==1) {
      this.vel.add(new PVector(tileSize/512f, 0));
    }

    if (rightTouch.isCollidable()) {
      if (arrows[3]==0) {
        if (jumpTimer==0 || this.vel.x>=-1e-5f)
          this.vel.set(new PVector(0, this.vel.y));
        else if (jumpTimer>0)
          this.vel.set(new PVector(-tileSize, this.vel.y));
      } else {
        this.vel.add(new PVector(-tileSize/512f, 0));
      }
      if (arrows[0]==1&&jumpTimer==0) {
        this.vel.set(new PVector(-tileSize/512f, (-tileSize/5f)));
        jumpTimer=2000;
      }
    }

    if (leftTouch.isCollidable()) {
      if (arrows[2]==0) {
        if (jumpTimer==0 || this.vel.x<=1e-5f)
          this.vel.set(new PVector(0, this.vel.y));
        else if (jumpTimer>0)
          this.vel.set(new PVector(tileSize, this.vel.y));
      } else {
        this.vel.add(new PVector(tileSize/512f, 0));
      }
      if (arrows[0]==1&&jumpTimer==0) {
        this.vel.set(new PVector(tileSize/512f, (-tileSize/5f)));
        jumpTimer=2000;
      }
    }

    if (upTouch.isCollidable()) {
      if (upTouch.id==9 && canToggle) {
        onoffstate = !onoffstate;
        toggle.play();
      }
      canToggle=false;
      float dist = (upTouch.hitBox.y+upTouch.hitBox.h)-upHit.y;
      this.vel.set(new PVector(this.vel.x, dist));
      this.vel.add(new PVector(0, 0.01f));
    } else {
      canToggle=true;
    }

    //println(this.vel);

    //this.vel.limit(tileSize);
    if (upTouch.id == 6 || downTouch.id == 6 || leftTouch.id == 6 || rightTouch.id == 6) {
      this.vel.x*=0.90f;
    } else {
      this.vel.x*=0.99f;
    }
    this.pos.y += this.vel.y/timeStep;
    this.pos.x += this.vel.x/timeStep;
    scrollX=-pos.x+(width/2);
    scrollY=-pos.y+(height/2);
    if (respawnTimer<=-1)
      for (Tile t : collide) {
        if (upHit.isTouching(t.hitBox) && t.isCollidable() && upTouch.id == -1) upTouch=t;
        if (downHit.isTouching(t.hitBox) && t.isCollidable() && downTouch.id == -1) downTouch=t;
        if (leftHit.isTouching(t.hitBox) && t.isCollidable() && leftTouch.id== -1) leftTouch=t;
        if (rightHit.isTouching(t.hitBox) && t.isCollidable() && rightTouch.id == -1) rightTouch=t;
      }

    if (upTouch.id == 3 || downTouch.id == 3 || leftTouch.id == 3 || rightTouch.id == 3) {
      respawn(true);
    }

    if (debug) {
      fill(255);
      rect(upHit.x, upHit.y, upHit.w, upHit.h);
      fill(255, 0, 0);
      rect(downHit.x, downHit.y, downHit.w, downHit.h);
      fill(0, 255, 0);
      rect(leftHit.x, leftHit.y, leftHit.w, leftHit.h);
      fill(0, 0, 255);
      rect(rightHit.x, rightHit.y, rightHit.w, rightHit.h);
    }

    for (Enemy e : enemies) {
      Rect enemyHit = new Rect(e.pos.x, e.pos.y, tileSize/2, tileSize/2);
      downHit = new Rect(pos.x-(tileSize/4)+(tileSize/9), pos.y-(tileSize/4)+(tileSize/2)-(tileSize/9), tileSize/2-(tileSize/9)*2, tileSize/9);
      leftHit = new Rect(pos.x-(tileSize/4), pos.y-(tileSize/4)+(tileSize/9), tileSize/9, tileSize/2-(tileSize/9)*2);
      rightHit = new Rect(pos.x-(tileSize/4)+(tileSize/2)-(tileSize/9), pos.y-(tileSize/4)+(tileSize/9), tileSize/9, tileSize/2-(tileSize/9)*2);
      upHit = new Rect(pos.x-(tileSize/4)+(tileSize/9), pos.y-(tileSize/4), tileSize/2-(tileSize/9)*2, tileSize/9);
      if (downHit.isTouching(enemyHit)) {
        kill.add(e);
        continue;
      }
      if (upHit.isTouching(enemyHit) || rightHit.isTouching(enemyHit) || leftHit.isTouching(enemyHit)) {
        respawn(true);
      }
    }
  }
}

class Rect {
  float x, y, w, h, defx, defy;

  public Rect(float x, float y, float w, float h) {
    this.x=x;
    this.y=y;
    this.defx=x;
    this.defy=y;
    this.w=w;
    this.h=h;
  }
  
  public void render(){
   rect(x,y,w,h); 
  }

  public boolean isTouching(Rect r) {
    return !(x + w < r.x
      || x > r.x + r.w
      || y > r.y+r.h
      || y+h < r.y );
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Jump_Platformer_Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
